# Best Practices for Writing Dockerfiles

- [Best Practices for Writing Dockerfiles](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)
- [Multi-stage builds](https://docs.docker.com/build/building/multi-stage/)
A docker image consists of read-only layers, each of which represents a Dockerfile instruction. We got the image by stacking layers together. Each layer represents the changes from the previous layer.

```Dockerfile
# syntax=docker/dockerfile:1
FROM ubuntu:18.04
COPY . /app
RUN make /app
CMD python /app/app.py
```

Details: 
- `FROM` creates the basic layer with Docker image `ubuntu:18.04`.
- `COPY` adds files in current directory to `/app` in `ubuntu` file system. **If directory `/app` not exits, a new folder will be created.**
- `RUN` uses `make` command to build the application.
- `CMD` specify what is the command to use when start the container.

## General guidelines and recommendations

### Create ephemeral containers
Containers generated by an image should be as `ephemeral` as possible, as containers are supposed to be stateless.

### Build context
A build's context is the set of files located at the `PATH` or `URL` specified as the positional argument to the build command. 

- Command
  `docker build [OPTIONS] PATH | URL | - `
- Example
  `docker build .` 

### Build from a local build context, using a Dockerfile from stdin
With `stdin`, you don't need to have a specific Dockerfile in the folder. Instead, docker will read in the docker file from `stdin`.

- Command
  `docker build [OPTIONS] -f- PATH`
- Parameters
  - `-f`: short for `--file` to specifify the Dockerfile to use
  - `-`: the `-` followed `-f` is to tell Docker to read the `Dockerfile` from `stdin`.
- Local Context Example
  ```bash
  # create a directory to work in 
  mkdir example
  cd example

  # create an example file 
  touch somefile.txt

  # build an image using the current directory as context, and a Dockerfile passed through stdin
  # /somefile.txt -> / is the root path
  docker build -t myimage:latest -f- . <<EOF
  FROM busybox
  COPY somefile.txt ./
  RUN cat /somefile.txt
  EOF
  ```
- Remote Context Example
  ```bash
  docker build -t myimage:latest -f- https://github.com/docker-library/hello-world.git << EOF
  FROM busybox
  COPY hello.c ./
  EOF
  ```

### Exclude with .dockerignore

LIke `.gitignore`, we can use `.dockerignore` file to neglect some files inside the docker build context. Syntax are the same.


### Use multi-stage builds

With `multi-stage builds`, we can reduce layers while building an image. 

- Example: A Dockerfile for a Go application could look like
  ```bash
  # syntax=docker/dockerfile:1
  FROM golang:1.16-alpine AS build
  
  # Install tools required for project
  # Run `docker build --no-cache .` to update dependencies
  RUN apk add --no-cache git
  RUN go get github.com/golang/dep/cmd/dep
  
  # List project dependencies with Gopkg.toml and Gopkg.lock
  # These layers are only re-built when Gopkg files are updated
  COPY Gopkg.lock Gopkg.toml /go/src/project/
  WORKDIR /go/src/project/
  # Install library dependencies
  RUN dep ensure -vendor-only
  
  # Copy the entire project and build it
  # This layer is rebuilt when a file changes in the project directory
  COPY . /go/src/project/
  RUN go build -o /bin/project
  
  # This results in a single layer image
  FROM scratch
  COPY --from=build /bin/project /bin/project
  ENTRYPOINT ["/bin/project"]
  CMD ["--help"]
  ```

### Decouple applications

After modulerize applications, it will be easier to scale different parts of an application horizontally and reuse containers.

### Minimize the number of layers

Only the instructions `RUN`, `COPY`, `ADD` create layers. Other instructions create temporary intermediate images, and do not increase the size of the build. 

## Docker Instructions

### `LABEL`

We can organize images by project using labels. Things like licensing information, automation needs can be achieved with `LABEL`. 

- Example 
  ```Dockerfile
  # Set one or more individual labels
  LABEL com.example.version="0.0.1-beta"
  LABEL vendor1="ACME Incorporated"
  LABEL vendor2=ZENITH\ Incorporated
  LABEL com.example.release-date="2015-02-12"
  LABEL com.example.version.is-production=""
  ```
- The above example can also be written as
  ```Dockerfile
  # Set multiple labels at once, using line-continuation characters to break long lines
  LABEL vendor=ACME\ Incorporated \
        com.example.is-beta= \
        com.example.is-production="" \
        com.example.version="0.0.1-beta" \
        com.example.release-date="2015-02-12"
  ```

### `RUN`

Better to split `RUN` command into multiple lines to increase the readability and maintainibility. 

- `apt-get`
  Install packages. 
  ```Dockerfile
  RUN apt-get update && apt-get install -y \
      package-bar \
      package-baz \
      package-foo \
      && rm -rf /var/lib/apt/lists/*
  ```
  - :warning: 

## TODO
- [ ] How to use `LABEL` in images organizing? For example, licensing and automation usage. Need concrete examples.
